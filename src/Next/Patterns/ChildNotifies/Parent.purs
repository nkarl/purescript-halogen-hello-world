module Next.Patterns.ChildNotifies.Parent where

import Prelude

import Data.Array (some)
import Data.Generic.Rep (class Generic)
import Data.Show.Generic (genericShow)
import Effect.Class (class MonadEffect)
import Effect.Class.Console (logShow)
import Halogen as H
import Halogen.HTML as HH
import Next.Patterns.ChildNotifies.Child.Button as Child
import Type.Proxy (Proxy(..))

type State = Int

data Action = HandleButton Child.Output

derive instance genericAction :: Generic Action _

instance showAction :: Show Action where
  show = genericShow

component :: forall q i o m. MonadEffect m => H.Component q i o m
component =
  H.mkComponent
  { initialState
  , render
  , eval: H.mkEval H.defaultEval
    { handleAction = handleAction
    }
  }
  where

  initialState :: i -> State
  initialState _ = 0

  render :: State -> H.ComponentHTML Action Child.Slots m
  render s =
    HH.div_
      [ HH.slot (Proxy :: Proxy "component") 0 Child.component s HandleButton
      , HH.div_ [ HH.text (show s) ]
      ]

  handleAction :: Action -> H.HalogenM State Action Child.Slots o m Unit
  handleAction = case _ of
                     HandleButton output -> case output of
                       Child.Clicked ->
                          do H.modify_ \s -> s + 1
                             logShow =<< H.get -- for debugging purpose in the browser console.


{--
  This example shows how to implement the Notify pattern.
  
  In this example, the Parent tracks an integer state. The Parent (as a component) is notified
  whenever an action event is fired as output from the Child. There is only one action variant
  in the child, hence only one variant case is handled. On receiving this action, the Parent's
  state is updated and the Parent rerendered.

  NOTE: Not entire sure about the use cases for a MonadAff Parent. When do we need to use MonadAff?
    Possibly when we need to wait for output from multiple childs asynchronously.
    This pattern seems to have a larger complexity space due to the async action events from a single
    Child and the action events from multiple async Child nodes.

  This is a simple example. However, we can imagine more complex situations. A possible scenario is
  when the Parent's state is in turn sent to the Child as input. This input might be used to constrain
  the actions generated by the Child.
--}
